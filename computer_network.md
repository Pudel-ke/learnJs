# 计算机网络

### 互联网是什么？

服务的角度来看

- 分布式应用进程
- 为分布式进程提供通信服务的基础设施

> 基础设施包括应用层以下的所有协议实体。(传输层、网络层、链路层、物理层，不包括应用)

组成的角度来看

- 网络边缘

> 主机系统(PC，Smartphone，pad)
>
> 应用程序(服务端程序、应用端程序)

- 网络核心(进行全球范围内端到端的数据交换)

> 互联着的路由器、交换机
>
> 网络的网络(通过网桥连接的多个网络)

- 接入网、物理媒体

> 有线或无线通信链路
>
> 将网络边缘接入网络核心的链路



#### 网络边缘

##### 采用网络设施的面向连接服务 （TCP协议

辨析:

> 面向连接，网络核心不知道连接状态，只在端系统中维护
>
> 有连接，网络核心中的节点同时维护。

目标：在端系统之间传输数据

握手：数据传输之前做好准备，两个通信主机之间为**连接建立状态**

TCP-传输控制协议

- Internet上面向连接的服务

TCP服务

- 可靠地、按顺序地传送数据 ： 确认和重传
- 流量控制： 发送方不会淹没接收方
- 拥塞控制：当网络拥塞时，发送方降低发送速率

> 使用TCP的应用： HTTP(Web)  FTP(文件传送)  Telnet(远程登录)  SMTP(email)

##### 采用基础设施的无连接服务 （UDP协议

目标： 在端系统之间传输数据

无连接服务

UDP-用户数据协议

- 无连接
- 不可靠数据传输
- 无流量控制
- 无拥塞控制

> 使用UDP的应用： 流媒体、远程会议、DNS、Internet电话



#### 网络核心

定义：路由器的网状网络

- 电(线)路交换：为每个呼叫预留一条专有电路，如电话网

  > 节点间的通信带宽分解成小片：
  >
  > 频分复用  FDM
  >
  > 时分复用  TDM
  >
  > 波分复用  WDM

  - 独享资源，不共享
  - 一旦呼叫建立就能保证性能
  - 如果没有数据发送，被分配的资源会被浪费
  - 通常被传统的电话网络采用

- 分组交换：具有很强的共享性

  - 将要传送的数据分成一个个单位(packet)

    - 特殊时分复用，链路资源
    - 统计多路复用，分组没有固定的模式

  - 将分组从一个路由器传送到相邻路由器(hop)，一段段最终从源端传到目标端

  - 每段采用链路**最大传输能力**(最大带宽)

  - 以分组为单位存储-转发方式packet-switch  分组每次移动一跳(hop)

    - 转发之前，节点必须收**到整个分组**
    - 延迟比线路交换要大
    - 存在不确定的排队时间

  - 排队和延迟

    - 如果到达速率>链路的输出速率

      分组将会排队，等待传输

    - 如果路由器的缓存用完，分组将会被抛弃 

##### 网络核心的关键功能

- **路由**

  决定分组采用的源到目标的路径

- **转发**

  将分组从路由器输入链路转移到输出链路



##### 数据报(datagram)的工作原理

(UDP)

- 通信之前，无需建立起一个连接，有数据就传输
- 每个分组都独立路由(路径不一样，可能会失序)
- 路由器根据分组的目标地址进行路由



##### 虚电路(virtual circuit)的工作原理

TCP

- 在分组交换网络上的两个或者多个端站点间的链路



#### 接入网和物理媒体

###### 住宅接入网络

> 有线接入(双绞线、同轴电缆、光纤、电力接入)

###### 单位接入网络

> Ethernet 以太网

##### 无线接入网络

> 无线LANS 从端系统到无线路由器
>
> 广域无线接入 (4G  5G  LTE) 由电信运行商提供

###### 专用接入网络



### Internet结构

##### ISP(互联网服务提供商)

帮用户接入internet

1. 第一层ISP
   - 直接与其他第一层ISP相连
   - 与大量的第二层ISP相连
2. 第二层ISP (通常是**区域I**SP)
   - 与一个或者多个第一层ISPs相连
   - 也可能与其他第二层ISPs
3. 第三层ISP(local)
   - 接入网

互联网络的结构：**网络**的**网络**

> N个ISPs  全连接，需要O(N*N)

将每个接入ISP都连接到全局ISP(全局范围内覆盖)？

- 客户ISPs和提供者ISPs有经纪合约
- 竞争：全局ISP是有利可为的**业务**，会有竞争者
- 通过ISP直接合作完成**业务**扩展，存在对等互联的结算关系(peer link)
- 完成业务细分

##### ICP 互联网内容提供商

内容提供商在全球部署自己的数据中心机房，通过专线连接。(如微软、谷歌等)



#### 协议层次和服务模型

> 协议的实现，借助于下层提供的服务。实现协议的目的，为了给上层提供更好的服务

PDU：协议数据单元  上层来的SDU通过层间接口后，加上本层的头部信息， 形成本层的PDU

**层次化实现复杂网络功能：**

- 将网络复杂的功能分成功能明确的**层次**，每一层实现了其中一个或一 组**功能**，功能中有其上层可以使用的功能：**服务** 
- 本层协议实体相互交互执行本层的**协议动作**，目的是**实现本层功能**， 通过接口**为上层提供更好的服务**  
- 在实现本层协议的时候，直接**利用了下层所提供的服务**  
- 本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+更下层所提供的服务

服务访问点(SAP): 下层向上层用户提供服务时用于区分要服务用户的信息。

原语(primitive)：上层通过SAP向下层告知需要使用什么服务

 

服务类型：

- 面向连接的服务   (TCP)
- 无连接的服务      (UDP)



#### Internet协议栈

- **应用层**  网络应用
  - 为人类用户或者其他应用进程提供网络应用服务。**应用报文**的交互 （message）
  - 协议：FTP , SMTP, HTTP,  DNS
- **传输层**  主机之间的数据传输，单位是**报文段** (message segment)
  - 在网络层提供的端到端通信基础上，细分为**进程到进程**。
  - 将不可靠通信变成可靠通信。
  - 协议：TCP,  UDP
- **网络层**  为(**分组**)从源到目的选择路由  (packet)
  - **主机主机**之间的通信，端到端通信，不可靠 （E2E）
  - 协议： **IP, 路由协议**
- **链路层**  相邻网络节点间的数据传输    (frame)
  - 2个相邻2点的通信，点到点通信，传输以**帧**为单位的数据。可靠或不可靠
- **物理层** 在物理线路上传送bit   (bit)



## 应用层

- **传输层的服务模型**
  - socket API

### 应用进程架构模式

- **客户-服务器模式 (C-S client-server)**

  - 服务器：
    - 一直运行
    - 固定的IP地址和周知的端口号
    - 扩展性差
  - 客户端：
    - 主动和服务器通信
    - 与互联网有间歇性的连接
    - 可能是动态IP地址
    - **不直接**与其他客户端通信

- **对等模式 (P2P)**

  - 没有一直运行的服务器
  - 任意端系统之间可以进行通信
  - 每个节点既是客户端又是服务器
  - 参与的主机间歇性连接且可以改变IP地址 --难以管理

- **混合体：C-S 和P2P结构**

  #### **内容分发网络 (CDN)**

  #### 网络应用实例：互联网流行的应用协议

  - **HTTP**
  - **FTP**
  - **SMTP/POP3/IMAP**
  - **DNS**

应用进程

- 客户端进程：发起通信的进程

- 服务器进程：等待通信的进程



**应用层向传输层传递数据：**

​	TCP socket：

- TCP服务，两个进程之间的通信需要之前建立连接
  - 两个进程通信会持续一段时间，通信关系稳定
- 可用一个整数表示两个应用实体之间的通信关系，为**本地**标示
- 穿过层间接口的信息量最小
- TCP socket： 源IP  源端口    目标IP  目标端口  代表了会话关系。同一个进程可能有不同的socket
- 套接字是4元组的一个具有**本地意义**的标示

UDP socket：

- UDP服务，两个进程之间通信不需要建立连接
  - 每个报文独立传输
  - 前后报文可能给不同的分布式进程
- 因此，只能用一个整数表示本应用实体的**本地**标示
  - 因为这个报文可能传给另一个分布式进程
- 穿过层间接口的信息大小最小
- UDP socket： 本IP  本端口
- 传输报文时，必须要提供对方的IP， port
  - 接收报文时，传输层需要上传对方的IP port 

#### 应用层协议

定义了运行在不同端系统上的应用进程如何相互交换报文：

- 交换的**报文类型** 请求和应答报文
- 各种报文类型的**语法**，报文中各个字段及其描述
- 字段的**语义**：即字段取值的含义
- 进程何时，如何发送报文及对报文进行响应的**规则**

> 对等层的应用进程在通信的过程中应当遵守的规则集合
>
> 仅仅是应用的一个组成部分

**应用实体：与网络交互有关的，遵守协议的应用部分**

传输层向上层提供的服务指标：延迟、吞吐量、可靠性(数据丢失率)、安全性

 **TCP:** 

1. 可提供服务

- 可靠的传输服务：

- 流量控制

  发送方不会淹没接收方

- 拥塞控制

  当网络出现拥塞时，能抑制发送方

2. 不能提供的服务

- 时间保证、最小吞吐保证和安全

3. 面向连接



**UDP：**

- 不可靠数据传输

**不**提供的服务：

可靠，流量控制，拥塞控制，时间，带宽保证，建立连接。



##### 安全TCP

SSL:安全套接字层

- 在TCP之上实现，提供加密的TCP连接
- 私密性
- 数据完整性
- 端到端的鉴别

SSL是运行在应用层的，库采用SSL库，使用TCP通信

SSL socket API

- 应用通过API将明文交给socket，SSL将其加密在互联网上传输



### HTTP

 **Web**:web包含一个基本的HTML文件，该基本HTML文件又包含若干对象的引用(链接)

URL：统一资源定位器。通过URL实现对每个对象的引用。

- 访问协议、用户名、口令字、端口

格式

- Prot://user:psw@www.someSchool.edu.cn:port/someDept/pic.gif

- 如：http://www.baidu.com/

  

**HTTP:超文本传输协议**

- 是Web的应用层协议

- C-S模式

  - 客户：请求，接收和显示web对象的浏览器
  - 服务器：对请求进行响应，发送对象的web服务器

  

**使用TCP**：

- 客户端发起一个与服务器的TCP连接(**建立套接字**)，端口号为80
- 服务器接受客户端的TCP连接
- HTTP客户端与Web服务器交换HTTP报文
- TCP连接关闭

> HTTP是无状态的，服务器不维护关于客户的任何信息。

**HTTP连接**：

- 非持久HTTP
  - 最多只有一个对象在TCP上连接上发送
  - 下载多个对象需要多个TCP连接
  - HTTP/1.0
  
- 持久HTTP
  - 多个对象可以在一个（客户端和服务器之间）TCP连接上传输
    - 非流水方式的持久HTTP
      - 客户端只能在收到前一个相应后才能发出新的请求
      - 每个引用对象花费一个RTT(round trip time)
    - 流水方式的持久HTTP
      - 客户端遇到一个引用对象就立即产生请求
      - 所有引用（小）对象只花费一个RTT是有可能的
    
  - HTTP/1.1
    - 默认使用流水方式
    
  - HTTP/2.0
  
    - 使用了双工模式，客户端可以同时发送多个请求，服务器可以同时响应多个请求。
    - 使用了多路复用技术，同一个TCP连接可以处理多个进程
    - 服务器可以主动向客户端发送数据
  
    

**HTTP请求报文**

- **请求**
  - 请求报文
    - 请求行(GET,POST,HEAD命令)
    - 首部行
    - 换行回车符 表示报文结束
  - 方法
    - GET 请求指定页面信息并返回响应主体，一般用于数据读取
    -  POST 向指定资源提交数据，请求服务器处理
    - HEAD（要求服务器在响应报文中不包含请求对象entity body）
    - PUT   向指定资源位置上传其最新内容
    - DELETE （删除URL字段规定的文件）
- **响应**
  - HTTP响应报文
    - 状态行(协议版本，状态码，相关状态信息)
    - 首部行 (Connection、Date等信息)
    - 数据，如请求的HTML文件

> **HTTP的首部有哪些？**
>
> - 通用首部：表示一些通用信息，如date表示报文创建时间
> - 请求首部：请求报文独有，如cookie、If-Modified-Since
> - 响应首部：响应报文独有，如set-cookie、Last-Modified
> - 实体首部：描述实体部分，如allow用来描述可执行的请求方法、content-type描述主体类型、content-Encoding描述主体的编码方式

> **get和post有什么区别**
>
> get和post本质上就是TCP链接，并无差别，但由于HTTP的规定和浏览器、服务器的限制，导致它们在应用过程中有一些不同：
>
> - get参数通过URL传递；post放在request body中
> - get请求在URL中传递的参数有长度限制；post没有（HTTP协议未规定，是因为浏览器和服务器的限制）
> - get请求只能进行URL编码；post请求有多种编码方式
> - get请求参数会被完整保留在浏览历史记录里；post中的参数不会被保留
> - get产生一个TCP数据包；post产生两个TCP数据包
> - 对于get请求，浏览器将http header和data一并发送，服务器响应200 OK；对于post请求，浏览器先发送header，服务器响应100 Continue，浏览器再发送data，服务器响应200 OK
> - 缓存方面：get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存；post请求一般做的是修改和删除工作，必须与数据库交互，所以不能使用缓存

**一、HTTP常见状态码**

按第一个数字分类：1表示信息，2表示成功，3表示重定向，4表示客户端错误，5表示服务器错误

|          状态码           |                             含义                             |
| :-----------------------: | :----------------------------------------------------------: |
|          200 OK           |               请求成功。一般用于get和post请求                |
|   301 Moved Permanently   |    永久移动。请求的信息已经被移动到新的URI，会返回新的URI    |
|         302 Found         |      临时移动。资源只是临时被移动，客户端继续使用原URI       |
|     304 Not Modified      | 未修改。所请求的资源未修改，服务器返回此状态码，不会返回任何资源 |
|      400 Bad Request      | 客户端请求的语法错误，服务器无法理解（产生原因：前端提交的数据在后台找不到与之相对应的实体） |
|     401 Unauthorized      |                     当前请求需要用户验证                     |
|       403 Forbidden       |                服务器已经收到请求，但拒绝执行                |
|       404 Not Found       |               服务器无法根据用户的请求找到资源               |
| 500 Internal Server Error |                 服务器内部错误，无法完成请求                 |



### DNS域名服务器

- 应用调用解析器(resolver)
- 解析器作为客户向Name Server发出查询报文(封装在UDP段中，端口号为53)
- Name Server返回响应报文(name/ip)

### CDN内容分发网络

> - 在CDN节点中存储内容的多个拷贝
> - 用户从CDN中请求内容，重定向到最近的拷贝，请求内容。

构建在现有网络基础之上的**智能虚拟网络**，依靠部署在各地的**边缘服务器**，通过中心平台的负载均衡、内容分发、调度等功能模块，使客户端向最近的(跳数最少的)CDN缓存节点请求资源,降低网络拥塞，提高响应速率的。

- enter deep

  将CDN服务器深入到许多接入网(如local ISP)

  - 更接近用户，数量多，离用户近，但管理困难
  - 如akami，有1700多个CDN

- bring home

  部署在少数(10个左右)关键位置，如将服务器安装于POP(入网点)附近

  - 采用租用线路将服务器簇连接起来
  - Limelight

用户从源服务器获得manifest告示文件，客户端请求对应资源时，通过manifest文件，c完成重定向，向最近的缓存节点请求资源。

**CDN运行在应用层，处于网络的边缘**

> over the top



## 传输层

### 传输层工作原理

#### 多路复用和解复用

- 复用： 从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口等信息对报文段勇头部加以封装(该头部信息用于以后的解复用)
- 根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)

#### 可靠数据传输

**RDT**

> 信道的不可靠性决定了实现RDT协议的复杂性

> 不出错、不丢失，基本可靠

**Rdt1.0** 在可靠信道上的可靠数据传输

- 下层信道完全可靠

  - 没有比特出错
  - 没有分组丢失

- 发送方和接收方的FSM(有限状态机)

  ![image-20211212170257579](C:\Users\邱珂\AppData\Roaming\Typora\typora-user-images\image-20211212170257579.png)

**Rdt2,0** 具有比特差错的信道

- 下层信道可能会出错：将分组中的比特翻转
  - 用校验和来检测比特差错
- 从差错中恢复：
  - 确认ACK：接收方显示地告诉发送方分组已被正确接受
  - 否认确定NAK：接收方显示地告诉发送方分组除了差错
    - 发送方收到NAK后，发送方重传分组
- Rdt2.0 中新机制： 采用差错控制编码进行差错检测
  - 发送发差错控制编码、缓存
  - 接收方使用编码检错
  - 接收方的反馈：控制报文（ACK,NAK）:接收方—>发送方
  - 发送方收到反馈相应的动作

- **缺陷**  一旦ACK/NAK出错，发送方不知道接收方发送什么事情

**Rdt2.1**  发送方在每个分组中加入**序号**

- 如果ACK/NAK出错，发送方**重传**当前分组
- 接收方丢弃（不发给上层）重复分组

> 一直到rdt2.1 都是执行停等协议：
>
> **即发送方发送一个分组，然后等待接收方的应答**

-    **summary**
  - 发送方：
    - 在分组中加入序列号
    - 两个序列号（0,1）1bit就足够
      - 一次只发送一个未经确认的分组
    - 必须检测ACK\NAK是否出错(需要EDC 差错校验码)
    - 状态数变成了两倍
      - 必须记住当前分组的序列号是0还是1
  - 接收方：
    - 必须检测接收到的分组是否是重复的
      - 状态会指示希望接收到的分组序号是0还是1
    - 接收方并不知道发送方是否正确收到了ACK\NAK
      - 没有安排确认的确认

**Rdt2.2** 无NAK的协议

- 功能同Rdt2.1 但没有NAK
- 接收方对**最后**正确接收的分组发ACK，以替代NAK
  - 接收方发送ACK必须显式地包含被正确接收的分组序号
- 当收到重复的ACK(如再次收到ACK0) ,发送方与收到NAK采取相同的动作：重传当前分组
- 为后面的一次发送多个数据单位做准备
  - 一次能发送多个
  - 避免每一个应答都有ACK，NAK
  - 使用对前一个数据单位的ACK，替代本数据单位的NAK
  - 确认信息减半，协议处理简单
- ![image-20211212172901287](C:\Users\邱珂\AppData\Roaming\Typora\typora-user-images\image-20211212172901287.png)

**Rdt3.0**具有比特差错和分组丢失的信道

- 新的假设：下层信道可能会丢失分组

  - 会死锁

    接收方在等待packet  发送方在等待ACK，没有下一步状态变化

  - 机制还不够处理这种状况：

    - 校验和
    - 序列号
    - ACK
    - 重传

- 方法：发送方等待ACK一段**合理的时间**

  - 发送端超时重传：如果没有及时收到ACK---重传

  - 问题：如果分组(或ACK)只是被延迟了 

    - 重传将会导致数据重复，但利用**序号**已经可以处理这个问题
    - 接收方必须指明被正确接收的序列号

  - 需要一个倒计数定时器。一般设置为正常往返更多的时间

  - > 超时定时器设置不合理，导致效率低，重发次数多。

    Rdt3.0可以工作，但在链路容量比较大的情况下，性能很差。链路容量比较大，一次发一个PDU不能充分利用链路的传输能力

    > 网络协议限制了物理资源的利用

  **流水线协议**

  流水线：允许发送方在**未得到对方确认**的情况下一次发送多个分组

  - 必须增加序号范围：用多个bit表示分组序号
  - 在发送方/接收方要有**缓冲区**
    - 发送方缓存：未得到确认，可能需要重传
    - 接收方缓存：上层用户取用数据的速率≠接收到的数据速率，接收到的数据可能乱序，排序交付（可靠）
  - 两种通用的流水线协议
    - 回退N步(GBN)
    - 选择重传(SR)
  - 通用：滑动窗口协议(slide window)
    - 发送缓冲区
      - 形式：内存中的一个区域，落入缓冲区的分组可以发送
      - 功能：用于存放已发送，但是没有得到确认的分组
      - 必要性：需要重发时可用
    - 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组
      - 停止等待协议=1
      - 流水线协议>1，合理的值，不能很大，链路利用率不能够超过100%
    - 发送缓冲区中的分组
      - 未发送的：落入发送缓冲区的分组，可以连续发送出去
      - 已发送出的，等待对方确认的分组，发送缓冲区的分组只有得到确认才能删除
    - 发送窗口：发送缓冲区内容的一个范围
      - **已发送**但是**未经确认**分组序号构成的空间
    - 发送窗口最大值≤发送缓冲区的值
    - 每发送一个分组，前沿移动一个单位
    - 接收窗口=接收缓冲区
      - 接收窗口用于控制哪些分组可以接收
        - 只有收到的分组序号落入接收窗口内才允许接收
        - 若序号落在接收窗口之外，则丢弃
      - 接收窗口尺寸Wr=1，回退N的ACK，即已接收的最高序号的ack。(GBN) 累计确认
      - 接收窗口Wr>1，则可以乱序接收接收窗口内的序号，并返回ACK(SR)   非累计确认--独立确认
        - 但提交给上层的分组，要按顺序
    - 出错率低：比较适合GBN，没有必要用复杂的SR为罕见的事件做复杂处理
    - 链路容量大（延迟大带宽大）：比较适合SR而不是GBN，否则一点出错代价太大。
    - GBN：发送端拥有对最老的未确认的分组的定时器。
      - 只需设置一个定时器
      - 当定时器到时时，重传所有未确认分组
    - SR： 发送方为每一个未确认的分组保持一个定时器
      - 当超时定时器到时时，只是重发到时时未确认的分组。

#### 流量控制

#### 拥塞控制

### TCP

- 多路复用、解复用
- 拥塞控制
- 流量控制
- 连接管理

> 发送方缓冲区： 用于超时重传
>
> 接收方缓冲区：用于匹配发送方的发送速率和接收方的接收速率。发送方不会淹没接收方。

应用层向下交的应用报文，会按照MSS大小被打成不同报文段，并加上20字节头部。

TCP报文结构

![image-20211215102013777](C:\Users\邱珂\AppData\Roaming\Typora\typora-user-images\image-20211215102013777.png)

序号：报文段首**字节**在字节流中的编号(偏移量)

确认号：期望从另一方收到的下一个**字节**的序号。 **累计确认**，确认号-1 及以前都被收到。

> 报文段没有规定接收方如何处理乱序

接收窗口：愿意接收的字节数量

TCP超时时间一天之内变化极大，在互联网之间超时时间是自适应的，但在局域网之间可以设置为固定。

SampleRTT 当前测量采样延时。

EstimatedRTT = (1-α)EstimatedRTT + α SampleRTT

超时时间= EstimatedRTT + 4*方差

#### 可靠数据传输

- 管道化的报文段
  - SR or GBN
- 累计确认 。像GBN，ACK=顺序到来的最高的字节序号+1
- 单个重传定时器。(像GBN),但只重传对应定时器的段，而非全部
- 是否可以接收乱序，没有规范

##### 快速重传

- 超时周期往往太长
- 通过**重复**的ACK来检测丢失的报文段
  - 发送方通常连续发送大量报文段
  - 如果报文段丢失，通常会引起多个重复的ACK
- 如果发送方收到同一数据的三个冗余ACK，重传最小序号段：
  - 快速重传：在**定时器过时之前**重发报文段

##### 流量控制

 接收方控制发送方，不让发送方发送太多、太快，以至于让接收方的缓存区溢出。

- 接收方在其向发送方的TCP段头部的rwnd字段中通告其空闲buffer的大小
- 发送方限制未确认字节的个数≤接收方的rwnd值
- 保证接收方不会被淹没

##### 连接管理

正式交换数据之前，发送方和接收方握手建立通信关系：

- 同意建立连接(每一方都知道对方愿意建立连接)三次握手
- 同一连接参数。初始序号，rcvdbuffer大小

###### 同意建立连接

> 两次握手
>
> - 变化的延迟，连接请求的段没有丢，但可能超时
> - 由于丢失造成的重传
> - 报文乱序
> - 互相看不到对方
>
> 导致 1. 半(虚假的)连接，只在服务器端维护了连接
>
> ​		2. 老的数据被当成新的数据接收了。

![image-20211215115433241](C:\Users\邱珂\AppData\Roaming\Typora\typora-user-images\image-20211215115433241.png)



**三次握手**

![img](https://barryyeee.github.io/InterviewGuide/Images/TCP%E6%8F%A1%E6%89%8B.png)

TCP三次握手：客户端和服务器都需要知道双方可收发，因此需要三次握手（让我知道你已经知道了）

TCP客户端最后还要发送一次确认的目的：防止已经失效的连接请求报文突然又传送到服务器，从而导致不必要的错误和资源的浪费。

**四次挥手**

“双向拆除”

对称释放、并不完美

![TCP挥手](C:\Users\邱珂\Pictures\TCP挥手.png)

- 客户端，服务器分别关闭它自己这一侧的连接。发送FIN bit = 1 的TCP段
- 一旦收到FIN，用ACK回应。接收到FIN段，ACK可以和它自己发出的FIN段一起发送
- 可以处理同时的FIN交换

**TCP客户端最后还要等待2*MSL（最长报文段寿命）的目的：保证客户端发送的最后一个ACK报文能够达到服务器；防止已经失效的关闭连接报文段出现在本连接中。**

Q1：如果已经建立了连接，但客户端突然出现故障怎么办？

TCP设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常设置为2h，若2h之内还没有收到客户端的任何数据，服务器就会发送一个探测报文，之后每隔75s发送一次。若连续发送10个探测报文仍没有回应，服务器就认为客户端出现故障，接着就关闭连接。

Q2：为什么建立连接是三次握手，关闭连接是四次挥手？

建立连接的时候，服务器出于监听状态，一旦收到客户端建立连接请求的SYN报文后，可直接将SYN和ACK放在一个报文中返回客户端。

而关闭连接时，服务器收到客户端关闭连接的FIN报文时仅仅表示对方不再发送数据但仍能接受数据，而自己的数据也未必全部发送给对方了，所以此时发送完数据给对方后，再向客户端发送FIN报文来表示同意现在关闭连接，ACK和FIN的分开发送导致挥手比握手多了一次。

#### 拥塞控制

拥塞：

- 非正式定义：“太多的数据需要网络传输，超过了**网络**的处理能力”
- 与流量控制不同
- 拥塞的表现：
  - 分组丢失(路由器缓冲区溢出)
  - 分组经历比较长的延迟(在路由器的队列中排队)

- 拥塞的产生

  - 发送给路由器的数据包速率大于路由器的转发速率
  - 数据在连路由器的缓存中排队
  - 队列增大至超过缓存最大值
  - 发送拥塞，无法缓存的数据包被丢弃

  储存空间不足：多个输入数据流传输到同一个输出端口，输出端口建立排队。若无足够存储空间存储，丢弃数据包。

  带宽容量不足：根据香农信息理论，信源发送的速率大于信道容量时，理论上不可能无差错传输，会导致超时重传。

  处理器处理能力弱，速度慢：路由器CPU在执行排队缓存，更新路由表等功能时，处理速度跟不上高速链路。

- 拥塞控制方法

  - 端到端拥塞控制(隐式)：
    - 没有来自网络的显式反馈
    - 端系统根据延迟和丢失时间推断是否拥塞
    - TCP采用的方法
  - 网络辅助的拥塞控制(显式)
    - 路由器提供给端系统以反馈信息
    - 单个bit置位，显示有拥塞(SNA,DECbit)
    - 显式提供发送端可以采用的速率

**TCP拥塞控制**

- 拥塞感知

  - 某个段超时了(丢失事件)：**拥塞**
    - 超时时间到，某个段的确认没有来
    - 原因1： 网络拥塞概率大
    - 原因2：出错被丢弃了 概率小
    - 一旦超时，就认为拥塞，有一定误判，但总体控制方向是对的
  - 有关某个段的三次重复ACK：**轻微拥塞**
    - 段的第一个ACK正常，期待新段
    - 段的第二个ack，意味着新段的后一段收到了
    - 段的第2，3,4,个ack重复，意味着新段后的三段都收到了。红点丢失的可能性很大
    - 网络这时还能进行一定程度的传输，拥塞但情况要比第一种好

- 拥塞控制

  - 控制发送端的发送速率
    - 维持一个拥塞窗口值:congWin (congestion window)
    - 发送端限制**已发送但未确认**的数据量
    - 从而粗略控制发送方往网络中注入的速率
      - rate≈congWin / RTT
  - congWin是动态的，是感知网络拥塞程度的函数
    - 超时或者三个重复的ACK，Congwin下降
      - 超时时：CongWin降为MSS(最大报文段长度)，进入慢启动阶段(SS)，加倍增加到Congwin/2，从而进入拥塞避免阶段(CA)
      - 3个重复的ACK：congwin降为congwin/2，CA阶段
      - 正常阶段：
        - SS：加倍增加（每个RTT）
        - CA：线性增加（每个RTT）

- 联合控制的方法：

  - 发送端控制*发送但未确认*的量同时也不能够超过接收窗口，满足流量控制要求。
    - SendWin = min(CongWin, RecvWin)
    - 同时满足拥塞控制和流量控制要求

  ![image-20211215165101413](C:\Users\邱珂\AppData\Roaming\Typora\typora-user-images\image-20211215165101413.png)

  1. 连接开始时，指数性增加发送速率，直到发生丢失事件
  2. 每一个RTT，congWin加倍
  3. 慢启动阶段：只要不超时或者重复ack，Congwin加倍
  4. AIMD 加(线)性增 乘性减
     1. **乘性减**  丢失事件后将CongWin降为1MSS,将CongWin/2作为阈值，进入慢启动阶段（倍增直到阈值）
     2. **加性增** 当CongWin大于阈值，但一个RTT没有发生丢失事件，将CongWIin加1MSS，探测。
     3. 收到3个ACKs之后
        - 门限变为congwin/2
        - congwin = 门限+3（个acks）
        - 窗口（缓冲区大小）线性增长。
     4. 当超时事件发生后，
        - congwin设置为1MSS。进入慢启动
        - 窗口指数增长
        - 增到上次发送拥塞的窗口的一半时，再线性增加

- TCP的公平性

  - k个主机分一个链路带宽为R的瓶頸，每个会话的有效带宽为R/K
  - 多媒体应用通常不是用TCP
  - 使用UDP：音视频应用泵出数据的速率是恒定的，忽略数据的丢失

### UDP

- 多路复用、解复用
- 没有为 尽力而为的IP服务添加更多的其他额外服务
  - 报文可能丢失
  - 送到应用进程的报文段乱序(数据报)
  - 每个UDP报文段都被独立处理

> 多被应用于流媒体、丢失不敏感、应用可控制传输速率
>
> DNS
>
> SNMP

- 实现可靠传输:
  - 在应用层增加可靠性
  - 应用层特定的差错恢复
- UDP校验和
  - 发送方：
    - 将报文段的内容视为16bit的整数
    - 校验和:报文段的加法和(最高位回卷，1的补运算)
    - 发送方将校验和放在UDP校验和字段
  - 接收方：
    - 计算接收到的报文段的校验和(不需要补运算)
    - 检查计算出的校验和于报文段校验和字段内容是否相等(和与校验和相加为ffff)
      - 不相等——检测到差错
      - 相等——没有检测到差错
        - 但或许有残存差错
  



# 网络安全

- 机密性：只有发送方和预订的接收方能否理解传输报文的内容
  - 发送方加密报文
  - 接收方解密报文
- 可认证： 发送方和接收方需要确认对方身份
- 报文完整性：发送方、接收方需要确认报文在传输的过程中或者事后没有被改变
- 访问控制和服务的可用性：服务可以接入以及对用户而言是可用的

### 加密语言

以Alice和Bob之间通信为例

- 对称秘钥密码学：发送方和接收方的密钥相同

  - DES
  - AES
  - 分块加密

- 公开密钥密码学：发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行解密

  - 明文plaintext经过密钥(key)加密后变成密文
  - 信道传输的都是密文
  - RSA算法
  - 私钥加密报文，变成数字签名，可用公钥解密。

  加密

  1. 需要私钥可以解密公钥加密的密文
  2. 给定一个公钥不能推出私钥，计算上不可行

### 数字签名

- 可验证性
- 不可伪造性
- 不可抵赖性

发送方使用自己的私钥对报文（摘要）进行加密得到数字签名，和报文一起发送。接收方使用发送方的公钥进行验证，判断是否发送方是否通过验证。

##### 报文摘要

对长报文进行公开密钥加密算法的实施乣耗费大量时间

- 通过散列函数将长报文映射成报文摘要
  - 散列函数特性
    - 多对一
    - 结果固定长度
    - 给定一个报文摘要x，反向计算出原报文在计算上是不可行的。

### 可信赖中介

#### 对称加密体系

KDC  key distribution center

- 服务器和每一个注册用户都分享一个对称密钥
- Alice和Bob在和KDC通信时，知道他们自己的对称密钥K_A-KDC和K_B-KDC
- ![image-20211217115144180](C:\Users\邱珂\AppData\Roaming\Typora\typora-user-images\image-20211217115144180.png)

#### 公开加密体系

CA   certification authorities

- CA将每一个注册实体E和他的公钥捆绑
- E到CA那里注册它的公钥
  - E提供给CA，自己身份的证据
  - CA创建一个证书(使用CA的私钥)，捆绑了实体信息和他(E)的公钥
  - 证书包括了E的公钥，而且是被CA签署的
- ![image-20211217115241771](C:\Users\邱珂\AppData\Roaming\Typora\typora-user-images\image-20211217115241771.png)
- F通过CA的公钥即可获得E的公钥。

### 各个层次的安全性

#### 安全电子邮件

- 私密电子邮件(不可认证、完整性不确定)

![image-20211217130814543](C:\Users\邱珂\AppData\Roaming\Typora\typora-user-images\image-20211217130814543.png)

- 可认证和报文完整性的邮件

![image-20211217131027811](C:\Users\邱珂\AppData\Roaming\Typora\typora-user-images\image-20211217131027811.png)

- 机密性 、可认证、完整性都具有

  ![image-20211217131156597](C:\Users\邱珂\AppData\Roaming\Typora\typora-user-images\image-20211217131156597.png)

  

#### 安全套接字层 

**secure sockets layers** 一般认为在应用层

- 为使用SSL服务的、基于TCP的应用提供传输层次的安全性
  - 在WEB浏览器和服务器之间进行电子商务的交易(shttp)
- 所提供的安全服务：
  - 服务器的可认证性，数据加密，客户端的可认证性（可选）
- TCP enhanced with SSL

1. 客户端通过URL发起HTTPS请求，要求服务器建立SSL链接
2. 服务器接收到客户端请求后，返回公钥证书
3. 客户端验证公钥证书是否有效，验证不通过则显式警告信息；验证通过则利用伪随机数生成器生成会话密钥，然后用证书的公钥加密会话秘钥并发送给服务器
4. 服务器通过自己的私钥解密会话秘钥。至此，客服端服务器双方都持有了相同的会话秘钥。
5. 客户端和服务器通过会话秘钥对称加密双方通信。

![img](https://barryyeee.github.io/InterviewGuide/Images/https%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg)

